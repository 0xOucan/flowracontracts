# User-Controlled Yield Donation - Architecture Design

**Branch:** `user-yield-control`
**Date:** November 7, 2025
**Status:** Design Phase

---

## üéØ Executive Summary

This document outlines the architectural changes required to transform Flowra from a **global yield distribution model** to a **per-user yield control model** that matches the frontend UI.

### Current System ‚ùå
- **Global allocation**: All users' yield is pooled and distributed to 6 fixed projects
- **Fixed percentages**: Project allocations are hardcoded (e.g., 30%, 25%, 20%, etc.)
- **No user choice**: Users cannot choose which projects to support
- **100% donated**: All yield goes to projects, none returns to users

### Required System ‚úÖ
- **Per-user allocation**: Each user controls their own yield distribution
- **User-selected projects**: Users choose 1-6 projects from 6 available options
- **User-selected percentage**: Users donate 1-20% of THEIR yield (80-99% returns to them)
- **Equal distribution**: User's donated yield is split equally among selected projects

---

## üìä Frontend Requirements (From UI Analysis)

### DCA Setup Wizard - Step 5: Impact & Projects

**User Inputs:**
1. **Donation Percentage Slider**: 1-20% (step: 1%)
   - Minimum: 1% (user keeps 99%)
   - Maximum: 20% (user keeps 80%)

2. **Project Selection**: Multi-select from 6 projects
   - Must select at least 1 project
   - Can select up to 6 projects
   - Donations split equally among selected projects

**Current Frontend Projects:**
1. Amazon Rainforest Restoration (Reforestation, Brazil)
2. Ocean Plastic Removal (Ocean Cleanup, Pacific Ocean)
3. Solar Power for Villages (Renewable Energy, Kenya)
4. Regenerative Farming Initiative (Sustainable Agriculture, India)
5. Coral Reef Restoration (Ocean Cleanup, Great Barrier Reef)
6. Wildlife Corridor Protection (Wildlife Conservation, Tanzania)
7. **Flowra** (Public Good, Web3) - **DEFAULT SELECTED**

**User Request:** Remove 1 project ‚Üí Only 6 projects total

---

## üèóÔ∏è Architecture Changes Required

### 1. Data Structure Changes (`FlowraTypes.sol`)

#### Current `UserPosition` Structure
```solidity
struct UserPosition {
    address owner;
    uint256 usdcDeposited;
    uint256 wethAccumulated;
    uint256 dailySwapAmount;
    uint256 lastSwapTimestamp;
    uint256 totalSwapsExecuted;
    uint256 yieldEarned;        // ‚Üê Not actually used currently
    bool active;
    uint256 createdAt;
}
```

#### NEW `UserPosition` Structure
```solidity
struct UserPosition {
    address owner;
    uint256 usdcDeposited;
    uint256 wethAccumulated;
    uint256 dailySwapAmount;
    uint256 lastSwapTimestamp;
    uint256 totalSwapsExecuted;

    // NEW: Yield tracking
    uint256 totalYieldEarned;      // Total yield generated by this user
    uint256 yieldDonated;          // Total yield donated to projects
    uint256 yieldClaimed;          // Total yield claimed by user
    uint256 pendingYield;          // Unclaimed yield available

    // NEW: User yield preferences
    uint256 donationPercentBps;    // 100-2000 (1%-20% in basis points)
    uint256[] selectedProjects;    // Array of project IDs (1-6)

    bool active;
    uint256 createdAt;
}
```

### 2. Deposit Function Changes (`FlowraCore.sol`)

#### Current Signature
```solidity
function deposit(uint256 amount) external returns (bytes32 positionId)
```

#### NEW Signature
```solidity
function deposit(
    uint256 amount,
    uint256 donationPercentBps,  // 100-2000 (1%-20%)
    uint256[] calldata projectIds // Array of project IDs to support
) external returns (bytes32 positionId)
```

#### Validation Logic
```solidity
// Donation percentage must be 1-20%
require(donationPercentBps >= 100 && donationPercentBps <= 2000, "Invalid donation %");

// Must select at least 1 project
require(projectIds.length > 0, "Must select at least 1 project");

// Must select at most 6 projects
require(projectIds.length <= 6, "Cannot select more than 6 projects");

// All project IDs must be valid (1-6)
for (uint256 i = 0; i < projectIds.length; i++) {
    require(projectIds[i] >= 0 && projectIds[i] < 6, "Invalid project ID");
}

// No duplicate project IDs
// (Implementation needed to check for duplicates)
```

### 3. Yield Harvesting Changes

#### Current Flow (Global)
```
Admin calls harvestYield()
  ‚Üì
Calculate total yield from Aave (all users combined)
  ‚Üì
Distribute 100% to fixed 6 projects with fixed allocations
```

#### NEW Flow (Per-User)
```
User calls claimYield() for their own position
  ‚Üì
Calculate user's share of Aave yield
  ‚Üì
Split into donation (1-20%) and user's portion (80-99%)
  ‚Üì
Distribute donation equally to user's selected projects
  ‚Üì
Send remaining yield to user
```

OR (Admin-triggered for all users):
```
Admin calls harvestAllYield()
  ‚Üì
For each active user position:
    Calculate user's yield share
    Apply user's donation %
    Distribute to user's selected projects
    Credit remaining to user's pendingYield
```

### 4. Yield Calculation Formula

```solidity
/**
 * Calculate individual user's yield from Aave
 *
 * User's yield = (User's USDC in Aave / Total USDC in Aave) * Total Aave Yield
 */
function calculateUserYield(address user) internal view returns (uint256) {
    UserPosition storage position = positions[user];

    // User's remaining USDC in Aave
    uint256 userUsdcInAave = position.usdcDeposited -
                              (position.totalSwapsExecuted * position.dailySwapAmount);

    // Total USDC from all users in Aave
    uint256 totalUsdcInAave = getTotalProtocolUSDCInAave();

    // Total yield from Aave
    uint256 totalAaveYield = aaveVault.getYieldEarned();

    // Proportional yield for this user
    return (totalAaveYield * userUsdcInAave) / totalUsdcInAave;
}
```

### 5. Project Management Changes (`FlowraYieldRouter.sol`)

#### Current
- Fixed 6 projects with fixed allocations
- Allocations must sum to 100% (10000 BPS)
- Validation enforces 100% total

#### NEW
- 6 projects with NO fixed allocations
- Projects are just wallets + metadata
- Each user distributes to their selected subset

```solidity
struct Project {
    address payable wallet;
    uint256 allocationBps;      // ‚Üê REMOVE THIS (no longer needed)
    uint256 totalReceived;
    bool active;
    string name;
    string description;
}
```

Becomes:

```solidity
struct Project {
    address payable wallet;
    uint256 totalReceived;      // Lifetime donations received
    uint256 donorCount;         // Number of users supporting this project
    bool active;
    string name;
    string description;
}
```

### 6. Yield Distribution Function

#### NEW Function in FlowraCore
```solidity
/**
 * @notice Claim and distribute user's accumulated yield
 * @dev User's yield is split based on their donation percentage
 *      Donation is distributed equally among their selected projects
 * @return userAmount USDC returned to user (80-99% of yield)
 * @return donatedAmount USDC donated to projects (1-20% of yield)
 */
function claimYield()
    external
    nonReentrant
    whenNotPaused
    returns (uint256 userAmount, uint256 donatedAmount)
{
    UserPosition storage position = positions[msg.sender];
    require(position.active, "No active position");

    // Calculate user's pending yield
    uint256 newYield = calculateUserYield(msg.sender);
    uint256 totalYield = position.pendingYield + newYield;

    require(totalYield > 0, "No yield to claim");

    // Calculate donation amount (1-20% based on user's choice)
    donatedAmount = (totalYield * position.donationPercentBps) / 10000;
    userAmount = totalYield - donatedAmount;

    // Withdraw total yield from Aave
    aaveVault.withdrawFromAave(totalYield);

    // Distribute donation equally to user's selected projects
    if (donatedAmount > 0 && position.selectedProjects.length > 0) {
        uint256 perProjectAmount = donatedAmount / position.selectedProjects.length;

        for (uint256 i = 0; i < position.selectedProjects.length; i++) {
            uint256 projectId = position.selectedProjects[i];
            Project storage project = yieldRouter.getProjectById(projectId);

            // Transfer to project
            USDC.safeTransfer(project.wallet, perProjectAmount);

            // Update stats
            project.totalReceived += perProjectAmount;
        }
    }

    // Transfer remaining yield to user
    if (userAmount > 0) {
        USDC.safeTransfer(msg.sender, userAmount);
    }

    // Update user stats
    position.totalYieldEarned += totalYield;
    position.yieldDonated += donatedAmount;
    position.yieldClaimed += userAmount;
    position.pendingYield = 0;

    emit YieldClaimed(msg.sender, userAmount, donatedAmount, block.timestamp);
}
```

---

## üîÑ Migration Path from Current Contracts

### Option A: Clean Deployment (Recommended for Hackathon)
1. Deploy new contracts from scratch
2. Frontend only interacts with new version
3. No migration needed (no existing users)

### Option B: Upgrade Existing Deployment
1. Deploy new versions of contracts
2. Add migration function to move positions
3. Users must manually migrate (complex, not recommended for hackathon)

**Recommendation:** Option A - Fresh deployment since this is for hackathon demo.

---

## üìù Implementation Checklist

### Phase 1: Update Data Structures
- [ ] Update `FlowraTypes.UserPosition` with yield tracking
- [ ] Add `donationPercentBps` field
- [ ] Add `selectedProjects[]` array
- [ ] Remove `allocationBps` from `Project` struct
- [ ] Add `donorCount` to `Project` struct

### Phase 2: Update FlowraCore
- [ ] Modify `deposit()` to accept donation % and projects
- [ ] Add validation for donation % (1-20%)
- [ ] Add validation for project selection (1-6 projects)
- [ ] Implement `calculateUserYield()` function
- [ ] Implement `claimYield()` function for users
- [ ] Add `getPendingYield(address user)` view function
- [ ] Add `updateYieldPreferences()` function (optional)

### Phase 3: Update FlowraYieldRouter
- [ ] Remove allocation validation (no longer needs 100%)
- [ ] Update `Project` struct
- [ ] Remove `distributeYield()` (replaced by per-user claims)
- [ ] Keep project registry management (add/remove/update)
- [ ] Add `recordDonation()` function for tracking

### Phase 4: Update FlowraAaveVault
- [ ] Add per-user yield tracking
- [ ] Implement proportional yield calculation
- [ ] Update `harvestYield()` to work with per-user model

### Phase 5: Update Tests
- [ ] Test deposit with user preferences
- [ ] Test yield calculation for multiple users
- [ ] Test claim yield with various donation %
- [ ] Test project distribution (equal split)
- [ ] Test edge cases (1 project, 6 projects, max %, min %)

### Phase 6: Update Deployment Scripts
- [ ] Update `Deploy.s.sol` with new constructor params
- [ ] Update `AddProjects.s.sol` (remove allocations)
- [ ] Create test script for user deposits with preferences

### Phase 7: Frontend Integration
- [ ] Update deposit call to include preferences
- [ ] Add claim yield button
- [ ] Display pending yield
- [ ] Show user's donation stats
- [ ] Show project support stats

---

## üí∞ Example Calculations

### Scenario: 3 Users with Different Preferences

**User A:**
- Deposited: 1000 USDC
- Donation %: 10%
- Selected Projects: [0, 1, 2] (Amazon, Ocean, Solar)
- Aave APY: 5%
- Annual Yield: 50 USDC
- Donated: 5 USDC (split: 1.67 to each project)
- Keeps: 45 USDC

**User B:**
- Deposited: 500 USDC
- Donation %: 20%
- Selected Projects: [3, 4] (Farming, Coral Reef)
- Aave APY: 5%
- Annual Yield: 25 USDC
- Donated: 5 USDC (split: 2.5 to each project)
- Keeps: 20 USDC

**User C:**
- Deposited: 200 USDC
- Donation %: 5%
- Selected Projects: [5] (Wildlife)
- Aave APY: 5%
- Annual Yield: 10 USDC
- Donated: 0.5 USDC (all to Wildlife)
- Keeps: 9.5 USDC

**Project Totals:**
- Amazon Rainforest: 1.67 USDC (from User A)
- Ocean Plastic: 1.67 USDC (from User A)
- Solar Power: 1.67 USDC (from User A)
- Regenerative Farming: 2.5 USDC (from User B)
- Coral Reef: 2.5 USDC (from User B)
- Wildlife: 0.5 USDC (from User C)

**Total Donated:** 10.5 USDC
**Total Kept by Users:** 74.5 USDC
**Percentage Donated:** ~12.3% overall (varies per user)

---

## üé® Frontend Data Flow

### Deposit Flow
```typescript
// Step 5: User selects preferences
const preferences = {
  donationPercent: 10,  // 10%
  selectedProjects: [0, 1, 2]  // Amazon, Ocean, Solar
}

// Step 6: Create strategy
await flowraCore.write.deposit([
  parseUnits("100", 6),  // 100 USDC
  1000,  // 10% in BPS
  [0, 1, 2]  // Project IDs
])
```

### Claim Yield Flow
```typescript
// User dashboard
const pendingYield = await flowraCore.read.getPendingYield([userAddress])

// Claim button
const { userAmount, donatedAmount } = await flowraCore.write.claimYield()

// Show breakdown
console.log(`You received: ${userAmount} USDC`)
console.log(`Donated: ${donatedAmount} USDC to your ${selectedProjects.length} projects`)
```

---

## üîê Security Considerations

### New Attack Vectors
1. **Front-running yield claims**: Mitigated by per-user tracking
2. **Project ID manipulation**: Validate project IDs in range [0, 5]
3. **Donation % manipulation**: Enforce 1-20% range
4. **Empty project array**: Require at least 1 project
5. **Duplicate projects**: Check for duplicates in array

### Gas Optimization
- **Concern**: Looping through user's selected projects on claim
- **Solution**: Limit max projects to 6 (low gas cost)
- **Worst case**: 6 projects √ó ~21k gas per transfer = ~126k gas for distributions

---

## üìö Octant v2 Integration Notes

### Current Octant Pattern (Analyzed)
Octant's `YieldDonatingTokenizedStrategy.sol`:
- Mints shares to "dragon router" representing profits
- Dragon router redistributes based on voting/allocation mechanism
- All profits go to dragon, none return to strategy holders

### Flowra's Adapted Pattern
- Users ARE the yield generators (not strategies)
- Each user controls their own donation percentage
- No voting needed - direct user choice
- Hybrid model: Some yield returns to user, some goes to projects

**Key Difference:** Flowra is **user-centric** while Octant is **protocol-centric**.

---

## ‚úÖ Success Criteria

Implementation is complete when:

- [ ] Users can deposit with custom donation % (1-20%)
- [ ] Users can select 1-6 projects during deposit
- [ ] Yield is calculated per-user proportionally
- [ ] Users can claim their yield (80-99% returned)
- [ ] Donated portion (1-20%) split equally to selected projects
- [ ] Projects receive correct amounts from all supporting users
- [ ] Frontend can query pending yield per user
- [ ] All tests pass with new user-controlled model
- [ ] Deployment script updated and working

---

## üìä Next Steps

1. **Review this design** - Confirm approach with team
2. **Update contracts** - Implement changes in order listed
3. **Write tests** - Comprehensive test coverage for new features
4. **Update frontend** - Integrate with new contract functions
5. **Deploy & test** - Deploy to testnet and verify end-to-end
6. **Document** - Update README and deployment guide

---

**Ready to implement?** Start with Phase 1: Update Data Structures in `FlowraTypes.sol`.
